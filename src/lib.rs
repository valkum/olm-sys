#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/* automatically generated by rust-bindgen */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 29;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OlmInboundGroupSession {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " get the size of an inbound group session, in bytes."]
    pub fn olm_inbound_group_session_size() -> usize;
}
extern "C" {
    #[doc = " Initialise an inbound group session object using the supplied memory"]
    #[doc = " The supplied memory should be at least olm_inbound_group_session_size()"]
    #[doc = " bytes."]
    pub fn olm_inbound_group_session(
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut OlmInboundGroupSession;
}
extern "C" {
    #[doc = " A null terminated string describing the most recent error to happen to a"]
    #[doc = " group session"]
    pub fn olm_inbound_group_session_last_error(
        session: *const OlmInboundGroupSession,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Clears the memory used to back this group session"]
    pub fn olm_clear_inbound_group_session(session: *mut OlmInboundGroupSession) -> usize;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store an inbound group session"]
    pub fn olm_pickle_inbound_group_session_length(session: *const OlmInboundGroupSession)
        -> usize;
}
extern "C" {
    #[doc = " Stores a group session as a base64 string. Encrypts the session using the"]
    #[doc = " supplied key. Returns the length of the session on success."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. If the pickle output buffer"]
    #[doc = " is smaller than olm_pickle_inbound_group_session_length() then"]
    #[doc = " olm_inbound_group_session_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\""]
    pub fn olm_pickle_inbound_group_session(
        session: *mut OlmInboundGroupSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Loads a group session from a pickled base64 string. Decrypts the session"]
    #[doc = " using the supplied key."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. If the key doesn't match the one used to"]
    #[doc = " encrypt the account then olm_inbound_group_session_last_error() will be"]
    #[doc = " \"BAD_ACCOUNT_KEY\". If the base64 couldn't be decoded then"]
    #[doc = " olm_inbound_group_session_last_error() will be \"INVALID_BASE64\". The input"]
    #[doc = " pickled buffer is destroyed"]
    pub fn olm_unpickle_inbound_group_session(
        session: *mut OlmInboundGroupSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Start a new inbound group session, from a key exported from"]
    #[doc = " olm_outbound_group_session_key"]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. On failure last_error will be set with an"]
    #[doc = " error code. The last_error will be:"]
    #[doc = ""]
    #[doc = "  * OLM_INVALID_BASE64  if the session_key is not valid base64"]
    #[doc = "  * OLM_BAD_SESSION_KEY if the session_key is invalid"]
    pub fn olm_init_inbound_group_session(
        session: *mut OlmInboundGroupSession,
        session_key: *const u8,
        session_key_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Import an inbound group session, from a previous export."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. On failure last_error will be set with an"]
    #[doc = " error code. The last_error will be:"]
    #[doc = ""]
    #[doc = "  * OLM_INVALID_BASE64  if the session_key is not valid base64"]
    #[doc = "  * OLM_BAD_SESSION_KEY if the session_key is invalid"]
    pub fn olm_import_inbound_group_session(
        session: *mut OlmInboundGroupSession,
        session_key: *const u8,
        session_key_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Get an upper bound on the number of bytes of plain-text the decrypt method"]
    #[doc = " will write for a given input message length. The actual size could be"]
    #[doc = " different due to padding."]
    #[doc = ""]
    #[doc = " The input message buffer is destroyed."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure."]
    pub fn olm_group_decrypt_max_plaintext_length(
        session: *mut OlmInboundGroupSession,
        message: *mut u8,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Decrypt a message."]
    #[doc = ""]
    #[doc = " The input message buffer is destroyed."]
    #[doc = ""]
    #[doc = " Returns the length of the decrypted plain-text, or olm_error() on failure."]
    #[doc = ""]
    #[doc = " On failure last_error will be set with an error code. The last_error will"]
    #[doc = " be:"]
    #[doc = "   * OLM_OUTPUT_BUFFER_TOO_SMALL if the plain-text buffer is too small"]
    #[doc = "   * OLM_INVALID_BASE64 if the message is not valid base-64"]
    #[doc = "   * OLM_BAD_MESSAGE_VERSION if the message was encrypted with an unsupported"]
    #[doc = "     version of the protocol"]
    #[doc = "   * OLM_BAD_MESSAGE_FORMAT if the message headers could not be decoded"]
    #[doc = "   * OLM_BAD_MESSAGE_MAC    if the message could not be verified"]
    #[doc = "   * OLM_UNKNOWN_MESSAGE_INDEX  if we do not have a session key corresponding to the"]
    #[doc = "     message's index (ie, it was sent before the session key was shared with"]
    #[doc = "     us)"]
    pub fn olm_group_decrypt(
        session: *mut OlmInboundGroupSession,
        message: *mut u8,
        message_length: usize,
        plaintext: *mut u8,
        max_plaintext_length: usize,
        message_index: *mut u32,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the number of bytes returned by olm_inbound_group_session_id()"]
    pub fn olm_inbound_group_session_id_length(session: *const OlmInboundGroupSession) -> usize;
}
extern "C" {
    #[doc = " Get a base64-encoded identifier for this session."]
    #[doc = ""]
    #[doc = " Returns the length of the session id on success or olm_error() on"]
    #[doc = " failure. On failure last_error will be set with an error code. The"]
    #[doc = " last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too"]
    #[doc = " small."]
    pub fn olm_inbound_group_session_id(
        session: *mut OlmInboundGroupSession,
        id: *mut u8,
        id_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the first message index we know how to decrypt."]
    pub fn olm_inbound_group_session_first_known_index(
        session: *const OlmInboundGroupSession,
    ) -> u32;
}
extern "C" {
    #[doc = " Check if the session has been verified as a valid session."]
    #[doc = ""]
    #[doc = " (A session is verified either because the original session share was signed,"]
    #[doc = " or because we have subsequently successfully decrypted a message.)"]
    #[doc = ""]
    #[doc = " This is mainly intended for the unit tests, currently."]
    pub fn olm_inbound_group_session_is_verified(
        session: *const OlmInboundGroupSession,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the number of bytes returned by olm_export_inbound_group_session()"]
    pub fn olm_export_inbound_group_session_length(session: *const OlmInboundGroupSession)
        -> usize;
}
extern "C" {
    #[doc = " Export the base64-encoded ratchet key for this session, at the given index,"]
    #[doc = " in a format which can be used by olm_import_inbound_group_session"]
    #[doc = ""]
    #[doc = " Returns the length of the ratchet key on success or olm_error() on"]
    #[doc = " failure. On failure last_error will be set with an error code. The"]
    #[doc = " last_error will be:"]
    #[doc = "   * OUTPUT_BUFFER_TOO_SMALL if the buffer was too small"]
    #[doc = "   * OLM_UNKNOWN_MESSAGE_INDEX  if we do not have a session key corresponding to the"]
    #[doc = "     given index (ie, it was sent before the session key was shared with"]
    #[doc = "     us)"]
    pub fn olm_export_inbound_group_session(
        session: *mut OlmInboundGroupSession,
        key: *mut u8,
        key_length: usize,
        message_index: u32,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OlmOutboundGroupSession {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " get the size of an outbound group session, in bytes."]
    pub fn olm_outbound_group_session_size() -> usize;
}
extern "C" {
    #[doc = " Initialise an outbound group session object using the supplied memory"]
    #[doc = " The supplied memory should be at least olm_outbound_group_session_size()"]
    #[doc = " bytes."]
    pub fn olm_outbound_group_session(
        memory: *mut ::std::os::raw::c_void,
    ) -> *mut OlmOutboundGroupSession;
}
extern "C" {
    #[doc = " A null terminated string describing the most recent error to happen to a"]
    #[doc = " group session"]
    pub fn olm_outbound_group_session_last_error(
        session: *const OlmOutboundGroupSession,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Clears the memory used to back this group session"]
    pub fn olm_clear_outbound_group_session(session: *mut OlmOutboundGroupSession) -> usize;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store an outbound group session"]
    pub fn olm_pickle_outbound_group_session_length(
        session: *const OlmOutboundGroupSession,
    ) -> usize;
}
extern "C" {
    #[doc = " Stores a group session as a base64 string. Encrypts the session using the"]
    #[doc = " supplied key. Returns the length of the session on success."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. If the pickle output buffer"]
    #[doc = " is smaller than olm_pickle_outbound_group_session_length() then"]
    #[doc = " olm_outbound_group_session_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\""]
    pub fn olm_pickle_outbound_group_session(
        session: *mut OlmOutboundGroupSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Loads a group session from a pickled base64 string. Decrypts the session"]
    #[doc = " using the supplied key."]
    #[doc = ""]
    #[doc = " Returns olm_error() on failure. If the key doesn't match the one used to"]
    #[doc = " encrypt the account then olm_outbound_group_session_last_error() will be"]
    #[doc = " \"BAD_ACCOUNT_KEY\". If the base64 couldn't be decoded then"]
    #[doc = " olm_outbound_group_session_last_error() will be \"INVALID_BASE64\". The input"]
    #[doc = " pickled buffer is destroyed"]
    pub fn olm_unpickle_outbound_group_session(
        session: *mut OlmOutboundGroupSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The number of random bytes needed to create an outbound group session"]
    pub fn olm_init_outbound_group_session_random_length(
        session: *const OlmOutboundGroupSession,
    ) -> usize;
}
extern "C" {
    #[doc = " Start a new outbound group session. Returns olm_error() on failure. On"]
    #[doc = " failure last_error will be set with an error code. The last_error will be"]
    #[doc = " NOT_ENOUGH_RANDOM if the number of random bytes was too small."]
    pub fn olm_init_outbound_group_session(
        session: *mut OlmOutboundGroupSession,
        random: *mut u8,
        random_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The number of bytes that will be created by encrypting a message"]
    pub fn olm_group_encrypt_message_length(
        session: *mut OlmOutboundGroupSession,
        plaintext_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Encrypt some plain-text. Returns the length of the encrypted message or"]
    #[doc = " olm_error() on failure. On failure last_error will be set with an"]
    #[doc = " error code. The last_error will be OUTPUT_BUFFER_TOO_SMALL if the output"]
    #[doc = " buffer is too small."]
    pub fn olm_group_encrypt(
        session: *mut OlmOutboundGroupSession,
        plaintext: *const u8,
        plaintext_length: usize,
        message: *mut u8,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the number of bytes returned by olm_outbound_group_session_id()"]
    pub fn olm_outbound_group_session_id_length(session: *const OlmOutboundGroupSession) -> usize;
}
extern "C" {
    #[doc = " Get a base64-encoded identifier for this session."]
    #[doc = ""]
    #[doc = " Returns the length of the session id on success or olm_error() on"]
    #[doc = " failure. On failure last_error will be set with an error code. The"]
    #[doc = " last_error will be OUTPUT_BUFFER_TOO_SMALL if the id buffer was too"]
    #[doc = " small."]
    pub fn olm_outbound_group_session_id(
        session: *mut OlmOutboundGroupSession,
        id: *mut u8,
        id_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Get the current message index for this session."]
    #[doc = ""]
    #[doc = " Each message is sent with an increasing index; this returns the index for"]
    #[doc = " the next message."]
    pub fn olm_outbound_group_session_message_index(session: *mut OlmOutboundGroupSession) -> u32;
}
extern "C" {
    #[doc = " Get the number of bytes returned by olm_outbound_group_session_key()"]
    pub fn olm_outbound_group_session_key_length(session: *const OlmOutboundGroupSession) -> usize;
}
extern "C" {
    #[doc = " Get the base64-encoded current ratchet key for this session."]
    #[doc = ""]
    #[doc = " Each message is sent with a different ratchet key. This function returns the"]
    #[doc = " ratchet key that will be used for the next message."]
    #[doc = ""]
    #[doc = " Returns the length of the ratchet key on success or olm_error() on"]
    #[doc = " failure. On failure last_error will be set with an error code. The"]
    #[doc = " last_error will be OUTPUT_BUFFER_TOO_SMALL if the buffer was too small."]
    pub fn olm_outbound_group_session_key(
        session: *mut OlmOutboundGroupSession,
        key: *mut u8,
        key_length: usize,
    ) -> usize;
}
pub const OLM_MESSAGE_TYPE_PRE_KEY: usize = 0;
pub const OLM_MESSAGE_TYPE_MESSAGE: usize = 1;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OlmAccount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OlmSession {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct OlmUtility {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Get the version number of the library."]
    #[doc = " Arguments will be updated if non-null."]
    pub fn olm_get_library_version(major: *mut u8, minor: *mut u8, patch: *mut u8);
}
extern "C" {
    #[doc = " The size of an account object in bytes"]
    pub fn olm_account_size() -> usize;
}
extern "C" {
    #[doc = " The size of a session object in bytes"]
    pub fn olm_session_size() -> usize;
}
extern "C" {
    #[doc = " The size of a utility object in bytes"]
    pub fn olm_utility_size() -> usize;
}
extern "C" {
    #[doc = " Initialise an account object using the supplied memory"]
    #[doc = "  The supplied memory must be at least olm_account_size() bytes"]
    pub fn olm_account(memory: *mut ::std::os::raw::c_void) -> *mut OlmAccount;
}
extern "C" {
    #[doc = " Initialise a session object using the supplied memory"]
    #[doc = "  The supplied memory must be at least olm_session_size() bytes"]
    pub fn olm_session(memory: *mut ::std::os::raw::c_void) -> *mut OlmSession;
}
extern "C" {
    #[doc = " Initialise a utility object using the supplied memory"]
    #[doc = "  The supplied memory must be at least olm_utility_size() bytes"]
    pub fn olm_utility(memory: *mut ::std::os::raw::c_void) -> *mut OlmUtility;
}
extern "C" {
    #[doc = " The value that olm will return from a function if there was an error"]
    pub fn olm_error() -> usize;
}
extern "C" {
    #[doc = " A null terminated string describing the most recent error to happen to an"]
    #[doc = " account"]
    pub fn olm_account_last_error(account: *mut OlmAccount) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A null terminated string describing the most recent error to happen to a"]
    #[doc = " session"]
    pub fn olm_session_last_error(session: *mut OlmSession) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " A null terminated string describing the most recent error to happen to a"]
    #[doc = " utility"]
    pub fn olm_utility_last_error(utility: *mut OlmUtility) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Clears the memory used to back this account"]
    pub fn olm_clear_account(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Clears the memory used to back this session"]
    pub fn olm_clear_session(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " Clears the memory used to back this utility"]
    pub fn olm_clear_utility(utility: *mut OlmUtility) -> usize;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store an account"]
    pub fn olm_pickle_account_length(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Returns the number of bytes needed to store a session"]
    pub fn olm_pickle_session_length(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " Stores an account as a base64 string. Encrypts the account using the"]
    #[doc = " supplied key. Returns the length of the pickled account on success."]
    #[doc = " Returns olm_error() on failure. If the pickle output buffer"]
    #[doc = " is smaller than olm_pickle_account_length() then"]
    #[doc = " olm_account_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\""]
    pub fn olm_pickle_account(
        account: *mut OlmAccount,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Stores a session as a base64 string. Encrypts the session using the"]
    #[doc = " supplied key. Returns the length of the pickled session on success."]
    #[doc = " Returns olm_error() on failure. If the pickle output buffer"]
    #[doc = " is smaller than olm_pickle_session_length() then"]
    #[doc = " olm_session_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\""]
    pub fn olm_pickle_session(
        session: *mut OlmSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Loads an account from a pickled base64 string. Decrypts the account using"]
    #[doc = " the supplied key. Returns olm_error() on failure. If the key doesn't"]
    #[doc = " match the one used to encrypt the account then olm_account_last_error()"]
    #[doc = " will be \"BAD_ACCOUNT_KEY\". If the base64 couldn't be decoded then"]
    #[doc = " olm_account_last_error() will be \"INVALID_BASE64\". The input pickled"]
    #[doc = " buffer is destroyed"]
    pub fn olm_unpickle_account(
        account: *mut OlmAccount,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Loads a session from a pickled base64 string. Decrypts the session using"]
    #[doc = " the supplied key. Returns olm_error() on failure. If the key doesn't"]
    #[doc = " match the one used to encrypt the account then olm_session_last_error()"]
    #[doc = " will be \"BAD_ACCOUNT_KEY\". If the base64 couldn't be decoded then"]
    #[doc = " olm_session_last_error() will be \"INVALID_BASE64\". The input pickled"]
    #[doc = " buffer is destroyed"]
    pub fn olm_unpickle_session(
        session: *mut OlmSession,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        pickled: *mut ::std::os::raw::c_void,
        pickled_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The number of random bytes needed to create an account."]
    pub fn olm_create_account_random_length(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Creates a new account. Returns olm_error() on failure. If there weren't"]
    #[doc = " enough random bytes then olm_account_last_error() will be"]
    #[doc = " \"NOT_ENOUGH_RANDOM\""]
    pub fn olm_create_account(
        account: *mut OlmAccount,
        random: *mut ::std::os::raw::c_void,
        random_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The size of the output buffer needed to hold the identity keys"]
    pub fn olm_account_identity_keys_length(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Writes the public parts of the identity keys for the account into the"]
    #[doc = " identity_keys output buffer. Returns olm_error() on failure. If the"]
    #[doc = " identity_keys buffer was too small then olm_account_last_error() will be"]
    #[doc = " \"OUTPUT_BUFFER_TOO_SMALL\"."]
    pub fn olm_account_identity_keys(
        account: *mut OlmAccount,
        identity_keys: *mut ::std::os::raw::c_void,
        identity_key_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The length of an ed25519 signature encoded as base64."]
    pub fn olm_account_signature_length(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Signs a message with the ed25519 key for this account. Returns olm_error()"]
    #[doc = " on failure. If the signature buffer was too small then"]
    #[doc = " olm_account_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\""]
    pub fn olm_account_sign(
        account: *mut OlmAccount,
        message: *const ::std::os::raw::c_void,
        message_length: usize,
        signature: *mut ::std::os::raw::c_void,
        signature_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The size of the output buffer needed to hold the one time keys"]
    pub fn olm_account_one_time_keys_length(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " Writes the public parts of the unpublished one time keys for the account"]
    #[doc = " into the one_time_keys output buffer."]
    #[doc = " <p>"]
    #[doc = " The returned data is a JSON-formatted object with the single property"]
    #[doc = " <tt>curve25519</tt>, which is itself an object mapping key id to"]
    #[doc = " base64-encoded Curve25519 key. For example:"]
    #[doc = " <pre>"]
    #[doc = " {"]
    #[doc = "     curve25519: {"]
    #[doc = "         \"AAAAAA\": \"wo76WcYtb0Vk/pBOdmduiGJ0wIEjW4IBMbbQn7aSnTo\","]
    #[doc = "         \"AAAAAB\": \"LRvjo46L1X2vx69sS9QNFD29HWulxrmW11Up5AfAjgU\""]
    #[doc = "     }"]
    #[doc = " }"]
    #[doc = " </pre>"]
    #[doc = " Returns olm_error() on failure."]
    #[doc = " <p>"]
    #[doc = " If the one_time_keys buffer was too small then olm_account_last_error()"]
    #[doc = " will be \"OUTPUT_BUFFER_TOO_SMALL\"."]
    pub fn olm_account_one_time_keys(
        account: *mut OlmAccount,
        one_time_keys: *mut ::std::os::raw::c_void,
        one_time_keys_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Marks the current set of one time keys as being published."]
    pub fn olm_account_mark_keys_as_published(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " The largest number of one time keys this account can store."]
    pub fn olm_account_max_number_of_one_time_keys(account: *mut OlmAccount) -> usize;
}
extern "C" {
    #[doc = " The number of random bytes needed to generate a given number of new one"]
    #[doc = " time keys."]
    pub fn olm_account_generate_one_time_keys_random_length(
        account: *mut OlmAccount,
        number_of_keys: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Generates a number of new one time keys. If the total number of keys stored"]
    #[doc = " by this account exceeds max_number_of_one_time_keys() then the old keys are"]
    #[doc = " discarded. Returns olm_error() on error. If the number of random bytes is"]
    #[doc = " too small then olm_account_last_error() will be \"NOT_ENOUGH_RANDOM\"."]
    pub fn olm_account_generate_one_time_keys(
        account: *mut OlmAccount,
        number_of_keys: usize,
        random: *mut ::std::os::raw::c_void,
        random_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The number of random bytes needed to create an outbound session"]
    pub fn olm_create_outbound_session_random_length(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " Creates a new out-bound session for sending messages to a given identity_key"]
    #[doc = " and one_time_key. Returns olm_error() on failure. If the keys couldn't be"]
    #[doc = " decoded as base64 then olm_session_last_error() will be \"INVALID_BASE64\""]
    #[doc = " If there weren't enough random bytes then olm_session_last_error() will"]
    #[doc = " be \"NOT_ENOUGH_RANDOM\"."]
    pub fn olm_create_outbound_session(
        session: *mut OlmSession,
        account: *mut OlmAccount,
        their_identity_key: *const ::std::os::raw::c_void,
        their_identity_key_length: usize,
        their_one_time_key: *const ::std::os::raw::c_void,
        their_one_time_key_length: usize,
        random: *mut ::std::os::raw::c_void,
        random_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Create a new in-bound session for sending/receiving messages from an"]
    #[doc = " incoming PRE_KEY message. Returns olm_error() on failure. If the base64"]
    #[doc = " couldn't be decoded then olm_session_last_error will be \"INVALID_BASE64\"."]
    #[doc = " If the message was for an unsupported protocol version then"]
    #[doc = " olm_session_last_error() will be \"BAD_MESSAGE_VERSION\". If the message"]
    #[doc = " couldn't be decoded then then olm_session_last_error() will be"]
    #[doc = " \"BAD_MESSAGE_FORMAT\". If the message refers to an unknown one time"]
    #[doc = " key then olm_session_last_error() will be \"BAD_MESSAGE_KEY_ID\"."]
    pub fn olm_create_inbound_session(
        session: *mut OlmSession,
        account: *mut OlmAccount,
        one_time_key_message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Create a new in-bound session for sending/receiving messages from an"]
    #[doc = " incoming PRE_KEY message. Returns olm_error() on failure. If the base64"]
    #[doc = " couldn't be decoded then olm_session_last_error will be \"INVALID_BASE64\"."]
    #[doc = " If the message was for an unsupported protocol version then"]
    #[doc = " olm_session_last_error() will be \"BAD_MESSAGE_VERSION\". If the message"]
    #[doc = " couldn't be decoded then then olm_session_last_error() will be"]
    #[doc = " \"BAD_MESSAGE_FORMAT\". If the message refers to an unknown one time"]
    #[doc = " key then olm_session_last_error() will be \"BAD_MESSAGE_KEY_ID\"."]
    pub fn olm_create_inbound_session_from(
        session: *mut OlmSession,
        account: *mut OlmAccount,
        their_identity_key: *const ::std::os::raw::c_void,
        their_identity_key_length: usize,
        one_time_key_message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The length of the buffer needed to return the id for this session."]
    pub fn olm_session_id_length(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " An identifier for this session. Will be the same for both ends of the"]
    #[doc = " conversation. If the id buffer is too small then olm_session_last_error()"]
    #[doc = " will be \"OUTPUT_BUFFER_TOO_SMALL\"."]
    pub fn olm_session_id(
        session: *mut OlmSession,
        id: *mut ::std::os::raw::c_void,
        id_length: usize,
    ) -> usize;
}
extern "C" {
    pub fn olm_session_has_received_message(session: *mut OlmSession) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Checks if the PRE_KEY message is for this in-bound session. This can happen"]
    #[doc = " if multiple messages are sent to this account before this account sends a"]
    #[doc = " message in reply. The one_time_key_message buffer is destroyed. Returns 1 if"]
    #[doc = " the session matches. Returns 0 if the session does not match. Returns"]
    #[doc = " olm_error() on failure. If the base64 couldn't be decoded then"]
    #[doc = " olm_session_last_error will be \"INVALID_BASE64\".  If the message was for an"]
    #[doc = " unsupported protocol version then olm_session_last_error() will be"]
    #[doc = " \"BAD_MESSAGE_VERSION\". If the message couldn't be decoded then then"]
    #[doc = " olm_session_last_error() will be \"BAD_MESSAGE_FORMAT\"."]
    pub fn olm_matches_inbound_session(
        session: *mut OlmSession,
        one_time_key_message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Checks if the PRE_KEY message is for this in-bound session. This can happen"]
    #[doc = " if multiple messages are sent to this account before this account sends a"]
    #[doc = " message in reply. The one_time_key_message buffer is destroyed. Returns 1 if"]
    #[doc = " the session matches. Returns 0 if the session does not match. Returns"]
    #[doc = " olm_error() on failure. If the base64 couldn't be decoded then"]
    #[doc = " olm_session_last_error will be \"INVALID_BASE64\".  If the message was for an"]
    #[doc = " unsupported protocol version then olm_session_last_error() will be"]
    #[doc = " \"BAD_MESSAGE_VERSION\". If the message couldn't be decoded then then"]
    #[doc = " olm_session_last_error() will be \"BAD_MESSAGE_FORMAT\"."]
    pub fn olm_matches_inbound_session_from(
        session: *mut OlmSession,
        their_identity_key: *const ::std::os::raw::c_void,
        their_identity_key_length: usize,
        one_time_key_message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Removes the one time keys that the session used from the account. Returns"]
    #[doc = " olm_error() on failure. If the account doesn't have any matching one time"]
    #[doc = " keys then olm_account_last_error() will be \"BAD_MESSAGE_KEY_ID\"."]
    pub fn olm_remove_one_time_keys(account: *mut OlmAccount, session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " The type of the next message that olm_encrypt() will return. Returns"]
    #[doc = " OLM_MESSAGE_TYPE_PRE_KEY if the message will be a PRE_KEY message."]
    #[doc = " Returns OLM_MESSAGE_TYPE_MESSAGE if the message will be a normal message."]
    #[doc = " Returns olm_error on failure."]
    pub fn olm_encrypt_message_type(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " The number of random bytes needed to encrypt the next message."]
    pub fn olm_encrypt_random_length(session: *mut OlmSession) -> usize;
}
extern "C" {
    #[doc = " The size of the next message in bytes for the given number of plain-text"]
    #[doc = " bytes."]
    pub fn olm_encrypt_message_length(session: *mut OlmSession, plaintext_length: usize) -> usize;
}
extern "C" {
    #[doc = " Encrypts a message using the session. Returns the length of the message in"]
    #[doc = " bytes on success. Writes the message as base64 into the message buffer."]
    #[doc = " Returns olm_error() on failure. If the message buffer is too small then"]
    #[doc = " olm_session_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\". If there"]
    #[doc = " weren't enough random bytes then olm_session_last_error() will be"]
    #[doc = " \"NOT_ENOUGH_RANDOM\"."]
    pub fn olm_encrypt(
        session: *mut OlmSession,
        plaintext: *const ::std::os::raw::c_void,
        plaintext_length: usize,
        random: *mut ::std::os::raw::c_void,
        random_length: usize,
        message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The maximum number of bytes of plain-text a given message could decode to."]
    #[doc = " The actual size could be different due to padding. The input message buffer"]
    #[doc = " is destroyed. Returns olm_error() on failure. If the message base64"]
    #[doc = " couldn't be decoded then olm_session_last_error() will be"]
    #[doc = " \"INVALID_BASE64\". If the message is for an unsupported version of the"]
    #[doc = " protocol then olm_session_last_error() will be \"BAD_MESSAGE_VERSION\"."]
    #[doc = " If the message couldn't be decoded then olm_session_last_error() will be"]
    #[doc = " \"BAD_MESSAGE_FORMAT\"."]
    pub fn olm_decrypt_max_plaintext_length(
        session: *mut OlmSession,
        message_type: usize,
        message: *mut ::std::os::raw::c_void,
        message_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Decrypts a message using the session. The input message buffer is destroyed."]
    #[doc = " Returns the length of the plain-text on success. Returns olm_error() on"]
    #[doc = " failure. If the plain-text buffer is smaller than"]
    #[doc = " olm_decrypt_max_plaintext_length() then olm_session_last_error()"]
    #[doc = " will be \"OUTPUT_BUFFER_TOO_SMALL\". If the base64 couldn't be decoded then"]
    #[doc = " olm_session_last_error() will be \"INVALID_BASE64\". If the message is for"]
    #[doc = " an unsupported version of the protocol then olm_session_last_error() will"]
    #[doc = " be \"BAD_MESSAGE_VERSION\". If the message couldn't be decoded then"]
    #[doc = " olm_session_last_error() will be BAD_MESSAGE_FORMAT\"."]
    #[doc = " If the MAC on the message was invalid then olm_session_last_error() will"]
    #[doc = " be \"BAD_MESSAGE_MAC\"."]
    pub fn olm_decrypt(
        session: *mut OlmSession,
        message_type: usize,
        message: *mut ::std::os::raw::c_void,
        message_length: usize,
        plaintext: *mut ::std::os::raw::c_void,
        max_plaintext_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " The length of the buffer needed to hold the SHA-256 hash."]
    pub fn olm_sha256_length(utility: *mut OlmUtility) -> usize;
}
extern "C" {
    #[doc = " Calculates the SHA-256 hash of the input and encodes it as base64. If the"]
    #[doc = " output buffer is smaller than olm_sha256_length() then"]
    #[doc = " olm_utility_last_error() will be \"OUTPUT_BUFFER_TOO_SMALL\"."]
    pub fn olm_sha256(
        utility: *mut OlmUtility,
        input: *const ::std::os::raw::c_void,
        input_length: usize,
        output: *mut ::std::os::raw::c_void,
        output_length: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " Verify an ed25519 signature. If the key was too small then"]
    #[doc = " olm_session_last_error will be \"INVALID_BASE64\". If the signature was invalid"]
    #[doc = " then olm_utility_last_error() will be \"BAD_MESSAGE_MAC\"."]
    pub fn olm_ed25519_verify(
        utility: *mut OlmUtility,
        key: *const ::std::os::raw::c_void,
        key_length: usize,
        message: *const ::std::os::raw::c_void,
        message_length: usize,
        signature: *mut ::std::os::raw::c_void,
        signature_length: usize,
    ) -> usize;
}
